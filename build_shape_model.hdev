<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.0" halcon_version="11.0.3.4" cs="1003013808">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_update_off ()</l>
<c></c>
<l>DataPath := './'</l>
<l>CaltabImageFileName := 'caltab_img.jpg'</l>
<l>CaltabFilename := DataPath + 'CalTabData/caltab_40mm.descr'</l>
<l>CaltabThickness := 1.0 / 1000.0</l>
<c></c>
<l>CamParamPath := './CamParams/CamParam_Interior_Raw_3.campar'</l>
<c></c>
<l>ObjectName := 'crml'</l>
<l>PartName := 'f'</l>
<l>BuildImageFilename := DataPath + ObjectName + '_find_img_' + PartName + '.jpg'</l>
<l>FindImageFilename := DataPath + ObjectName + '_find_img_' + PartName + '.jpg'</l>
<c></c>
<l>TextColor := 'white'</l>
<l>BgColor1 := 'coral'</l>
<l>BgColor2 := 'red'</l>
<l>Margin := 3</l>
<c></c>
<l>read_cam_par(CamParamPath,CamParamIn)</l>
<l>tuple_gen_const (|CamParamIn| - 7, 0, zeros)</l>
<l>change_radial_distortion_cam_par ('preserve_resolution', CamParamIn, zeros, CamParam)</l>
<l>gen_radial_distortion_map (UnDistMap, CamParamIn, CamParam, 'bilinear')</l>
<c></c>
<l>read_image (CaltabRawImage, CaltabImageFileName)</l>
<l>dev_open_window_fit_image (CaltabRawImage, 0, 0, -1, -1, WindowHandle)</l>
<l>map_image (CaltabRawImage, UnDistMap, CaltabMappedImage)</l>
<l>get_caltab_pose (CaltabMappedImage, CaltabRegion, CaltabFilename, CamParam, CaltabThickness, ReferencePoseInCam)</l>
<l>dev_clear_window ()</l>
<l>dev_display (CaltabMappedImage)</l>
<c></c>
<c>* current graphics context settings:</c>
<l>dev_set_colored (3)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c>* end of graphics context settings</c>
<l>dev_display (CaltabRegion)</l>
<l>disp_3d_coord_system (WindowHandle, CamParam, ReferencePoseInCam, 0.05) </l>
<l>disp_message (WindowHandle, 'Press F5 to Continue.', 'window', 0, 0, 'black', 'true')</l>
<c>    </c>
<l>stop ()</l>
<c></c>
<l>gen_normalize_map (NormalizeMap, ReferencePoseInCam, CamParam, [], NormalizedScale)</l>
<l>read_image (WorkRawImage, BuildImageFilename)</l>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>* open_framegrabber ('uEye', 1, 1, 0, 0, 0, 0, 'default', 8, 'default', -1, 'false', 'default', '3', 0, -1, AcqHandle)</l>
<l>* grab_image_start (AcqHandle, -1)</l>
<l>* grab_image_async (WorkRawImage, AcqHandle, -1)</l>
<c>* Image Acquisition 01: Do something</c>
<l>* close_framegrabber (AcqHandle)</l>
<l>map_image (WorkRawImage, UnDistMap, WorkMappedImage)</l>
<l>map_image (WorkMappedImage, NormalizeMap, WorkNormImage)</l>
<c></c>
<l>gen_empty_obj (ModelSelectRegion)</l>
<l>while(true)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display(WorkNormImage)</l>
<l>    dev_set_draw('margin')</l>
<l>    dev_set_color('red')</l>
<l>    dev_display (ModelSelectRegion)</l>
<l>    disp_message (WindowHandle, 'ワーク領域を選択します。形状を選んでください。', 'window', 0, 0, 'black', 'true')</l>
<l>    Texts := ['Circle', 'Ellipse', 'Line', 'Rectangle1', 'Rectangle2', 'Polygon']</l>
<l>    select_button_ex (WindowHandle, Texts, 16, 0, TextColor, BgColor1, BgColor2, Margin, 'window', 'true', SelectedShape)</l>
<l>    if (SelectedShape = 0)</l>
<l>        ShapeType := 'Circle'</l>
<l>    elseif (SelectedShape = 1)</l>
<l>        ShapeType := 'Ellipse'</l>
<l>    elseif (SelectedShape = 2)</l>
<l>        ShapeType := 'Line'</l>
<l>    elseif (SelectedShape = 3)</l>
<l>        ShapeType := 'Rectangle1'</l>
<l>    elseif (SelectedShape = 4)</l>
<l>        ShapeType := 'Rectangle2'</l>
<l>    else</l>
<l>        ShapeType := 'Polygon'</l>
<l>    endif</l>
<l>    dev_clear_window ()</l>
<l>    dev_display(WorkNormImage)</l>
<l>    dev_set_draw('margin')</l>
<l>    dev_set_color('red')</l>
<l>    dev_display (ModelSelectRegion)</l>
<l>    disp_message (WindowHandle, '矩形で周辺を拡大後、領域を選択してください。', 'window', 0, 0, 'black', 'true')</l>
<l>    make_region (WorkNormImage, ModelSelectRegion, ModelSelectRegion, WindowHandle, ShapeType, 1, 'Add')</l>
<l>    disp_message (WindowHandle, '領域を追加しますか？', 'window', 0, 0, 'black', 'true')</l>
<l>    Texts := ['はい', 'いいえ']</l>
<l>    select_button_ex (WindowHandle, Texts, 16, 0, TextColor, BgColor1, BgColor2, Margin, 'window', 'true', SelectedShape)</l>
<l>    if (SelectedShape = 1)</l>
<l>        break</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l>dev_clear_window ()</l>
<l>dev_display(WorkNormImage)</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_color('red')</l>
<l>dev_display (ModelSelectRegion)</l>
<c></c>
<l>rgb1_to_gray (WorkNormImage, WorkGrayImage)</l>
<l>reduce_domain (WorkGrayImage, ModelSelectRegion, SubmitImage)</l>
<c></c>
<l>crop_domain (SubmitImage, ImagePart)</l>
<c>* Create the local deformable model with use_polarity as metric.</c>
<l>create_local_deformable_model (SubmitImage, 'auto', -3.14, 6.29, 'auto', 0.9, 1.1, 'auto', 0.9, 1.1, 'auto', 'none', 'use_polarity', 'auto', 'auto', [], [], ModelID)</l>
<l>get_deformable_model_contours (ModelContours, ModelID, 1)</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* Open a window for the comparison of the rectified</c>
<c>* matches with the cropped model image.</c>
<l>get_image_size (ImagePart, WidthPart, HeightPart)</l>
<l>WindowWidthPart := 2 * WidthPart</l>
<l>WindowHeightPart := 2 * HeightPart</l>
<c>* For demonstration purposes, the matching is applied to</c>
<c>* search images that show the logo with an increasing</c>
<c>* magnitude of artificial deformations.</c>
<c></c>
<l>        find_local_deformable_model (WorkGrayImage, ImageRectified, VectorField, DeformedContours, ModelID, -3.14, 6.29, 0.9, 1.1, 0.9, 1.1, 0.6, 0, 1, 4, 0.9, ['image_rectified','vector_field','deformed_contours'], ['deformation_smoothness','expand_border','subpixel'], [21,0,1], Score, Row, Column)</l>
<c></c>
<l>        dev_set_window (WindowHandle)</l>
<c>        * For the visualization we use the returned vector field</c>
<c>        * and generate a grid of the deformation in the search image.</c>
<l>        gen_warped_mesh (VectorField, WarpedMesh, 20)</l>
<c>        </c>
<l>        gen_region_contour_xld (WarpedMesh, Region, 'filled')        </l>
<c>        </c>
<l>        count_obj (Region, num)</l>
<c>       </c>
<l>        union1 (Region, RegionUnion)</l>
<c>        </c>
<l>        fill_up_shape (RegionUnion, RegionFillUp, 'area', 1, 10000)</l>
<l>        connection (RegionFillUp, ConnectedRegions)</l>
<l>        *fit_rectangle2_contour_xld (WarpedMesh, 'regression', -1, 0, 0, 3, 2, Row1, Column1, Phi, Length1, Length2, PointOrder)</l>
<l>        *gen_rectangle2_contour_xld (Rectangle, Row1, Column1, Phi, Length1, Length2)</l>
<c>        </c>
<l>        dev_display (WorkNormImage)</l>
<l>        dev_set_color ('white')</l>
<l>        dev_set_line_width (1)</l>
<l>        dev_display (WarpedMesh)</l>
<l>        dev_set_line_width (2)</l>
<l>        dev_set_color ('black')</l>
<l>        dev_set_draw ('margin')</l>
<l>        *dev_display (ConnectedRegions)</l>
<c>        </c>
<l>        gen_contour_region_xld (ConnectedRegions, XLDContour, 'border')</l>
<c>        </c>
<l>        *dev_display (XLDContour)</l>
<l>        fit_rectangle2_contour_xld (XLDContour, 'regression', -1, 0, 0, 3, 2, Row3, Column3, Phi1, Length11, Length21, PointOrder1)</l>
<l>        gen_rectangle2 (Rectangle1, Row3, Column3, Phi1, Length11, Length21)</l>
<l>        dev_display (Rectangle1)</l>
<c></c>
<l>        dev_set_draw ('margin')</l>
<l>        dev_set_color ('black')</l>
<l>        *gen_rectangle2_contour_xld (Rectangle, Row1, Column1, Phi, Length1, Length2)</l>
<l>        dev_display (DeformedContours)</l>
<c>        </c>
<l>        ObjPosesInCam := []</l>
<l>        dev_set_colored(3)</l>
<l>        for i := 0 to |Row3| - 1 by 1</l>
<l>            convert_poses_from_2d_to_camera_with_plane_pose (CamParam, ReferencePoseInCam, Row3[i], Column3[i], Phi1[i], objPoseInCam)</l>
<l>            disp_3d_coord_system (WindowHandle, CamParam, objPoseInCam, 0.02)</l>
<l>            tuple_concat (ObjPosesInCam, objPoseInCam, ObjPosesInCam)</l>
<l>        endfor</l>
<c>        </c>
<l>        *         optical_flow_mg (ImagePart, ImageRectified, VectorField1, 'clg', 0.7, 1, 20, 5, 'default_parameters', 'very_accurate')</l>
<l>*         unwarp_image_vector_field (ImageRectified, VectorField1, ImageUnwarped)</l>
<l>*         vector_field_to_real (VectorField1, RowField, ColField)</l>
<l>*         vector_field_length (VectorField1, Length, 'length')</l>
<l>*         abs_diff_image (ImagePart, ImageUnwarped, ImageAbsDiff, 1)</l>
<l>*         stop ()</l>
<c>* </c>
<c>* Clean up</c>
<l>gen_empty_obj (ModelSelectRegion)</l>
<l>gen_empty_obj (OriginRegion)</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="gen_normalize_map">
<interface>
<oo>
<par name="NormalizeMap"/>
</oo>
<ic>
<par name="UndistRefPoseInCam"/>
<par name="UndistCamParam"/>
<par name="ScaleIn"/>
</ic>
<oc>
<par name="ScaleOut"/>
</oc>
</interface>
<body>
<l>project_3d_point (UndistRefPoseInCam[0], UndistRefPoseInCam[1], UndistRefPoseInCam[2], UndistCamParam, row, col)</l>
<l>widthMappedImage := UndistCamParam[|UndistCamParam|-2]</l>
<l>heightMappedImage := UndistCamParam[|UndistCamParam|-1]</l>
<c>* Determine the scale for the mapping</c>
<c>* (here, the scale is determined such that in the</c>
<c>*   surroundings of the given point  the image scale of the</c>
<c>*   mapped image is similar to the image scale of the original image)</c>
<l>distICS := 1</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row, col, 1, centerX, centerY)</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row + distICS, col, 1, belowCenterX, belowCenterY)</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row, col + distICS, 1, rightOfCenterX, rightOfCenterY)</l>
<l>distance_pp (centerY, centerX, belowCenterY, belowCenterX, dist_WCS_Vertical)</l>
<l>distance_pp (centerY, centerX, rightOfCenterY, rightOfCenterX, dist_WCS_Horizontal)</l>
<l>scaleVertical := dist_WCS_Vertical / distICS</l>
<l>scaleHorizontal := dist_WCS_Horizontal / distICS</l>
<l>ScaleOut := (scaleVertical + scaleHorizontal) / 2.0</l>
<c>* Determine the parameters for set_origin_pose such</c>
<c>* that the point given via get_mbutton will be in the center of the</c>
<c>* mapped image</c>
<c></c>
<l>if (|ScaleIn| = 1)</l>
<l>    ScaleOut := ScaleIn</l>
<l>endif</l>
<c>* </c>
<l>dx := centerX - ScaleOut * widthMappedImage / 2.0</l>
<l>dy := centerY - ScaleOut * heightMappedImage / 2.0</l>
<l>dz := 0.0</l>
<l>set_origin_pose (UndistRefPoseInCam, dx, dy, dz, PoseForCenteredImage)</l>
<c>* ---------------------------------------------------</c>
<c>* </c>
<c>* Generate normalize map</c>
<l>gen_image_to_world_plane_map (NormalizeMap, UndistCamParam, PoseForCenteredImage, widthMappedImage, heightMappedImage, widthMappedImage, heightMappedImage, ScaleOut, 'bilinear')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_normalize_map">
<abstract lang="ja_JP">ワークがカメラ座標系で正対するような補正マップを生成します。

画像上のワークサイズが同等になるよう正規化する場合は，空tuple ( [ ] ) を指定してください。

複数段トレイを同一サイズで正規化する場合は，FixedScale に正の数値を指定してください。
</abstract>
<attention lang="ja_JP">正対化の手法自体は， HDevelopサンプル transform_image_into_wcs.dev の内部プロシージャー parameters_image_to_world_plane_centered と同一です。
</attention>
<chapters lang="ja_JP">
<item>Samples</item>
</chapters>
<library lang="ja_JP">NEXTAGE Vision Procedures</library>
<see_also>
<item>gen_image_to_world_plane_map</item>
<item>parameters_image_to_world_plane_centered</item>
</see_also>
<short lang="ja_JP">ワークがカメラ座標系で正対するような補正マップを生成します。</short>
<parameters>
<parameter id="NormalizeMap">
<description lang="ja_JP">正対化するマッピング画像</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
</type_list>
</parameter>
<parameter id="ScaleIn">
<default_value>[]</default_value>
<description lang="ja_JP">スケール
 (詳しくは gen_image_to_world_plane_map の Scale を参照のこと)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleOut">
<description lang="ja_JP">自動計算されたスケール
 (ScaleIn 指定時は同一値が返されます)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="UndistCamParam">
<description lang="ja_JP">歪み補正/平行化済みの内部カメラパラメーター</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="UndistRefPoseInCam">
<description lang="ja_JP">歪み補正/平行化済みのカメラ座標系での平面の位置・姿勢</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_button_ex">
<interface>
<ic>
<par name="WindowHandle"/>
<par name="Texts"/>
<par name="Rows"/>
<par name="Columns"/>
<par name="TextColor"/>
<par name="BgColor"/>
<par name="SelectedBgColor"/>
<par name="Margin"/>
<par name="CoordSystem"/>
<par name="WaitSelection"/>
</ic>
<oc>
<par name="SelectedIndex"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。</c>
<c>* </c>
<c>* </c>
<l>ButtonSpace := 10</l>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<c>* オプション文字列を '///' でパースする</c>
<l>tuple_gen_const (|Texts|, '', textOptions)</l>
<l>for i := 0 to |Texts| - 1 by 1</l>
<l>    pos := strstr (Texts[i], '///')</l>
<l>    if (pos &gt;= 0)</l>
<l>        textOptions[i] := Texts[i]{pos + 3 : strlen(Texts[i]) - 1}</l>
<l>        Texts[i] := Texts[i]{0 : pos - 1}</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>get_system (['width', 'height'], SysInfos)</l>
<l>if (SysInfos[0] &lt; WidthWin or SysInfos[1] &lt; HeightWin)</l>
<l>    set_system (['width', 'height'], [max2(SysInfos[0], WidthWin), max2(SysInfos[1], HeightWin)])</l>
<l>endif</l>
<c>* </c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>dev_set_part (0, 0, HeightWin-1, WidthWin-1)</l>
<l>dev_set_draw ('fill')</l>
<c>* </c>
<l>if (false)</l>
<c>    * 画像が表示されたウィンドウをクリックすると現在の part で再表示されてしまうため，見かけを戻すために表示する。</c>
<c>    * 途中のウィンドウサイズ変更は考慮しない。</c>
<l>    dump_window_image (DumpedImage, WindowHandle)</l>
<l>    dev_display (DumpedImage)</l>
<l>else</l>
<c>    * 上記対策を行うと，関数から戻った後にグラフィックウィンドウでウィンドウサイズを 25% などに変更した場合に</c>
<c>    * 不都合が出る (ウィンドウサイズが DumpedImage の 25% などになる)。</c>
<c>    * こちらの方が不便なため，ここでは対処しない。</c>
<c>    * 必要に応じてユーザー側で本コマンド呼出し後に画像の dev_display を行ってもらう。</c>
<l>endif</l>
<c>* </c>
<c>* Rows, Columns を生成</c>
<l>if (|Rows| # |Texts| or |Columns| # |Texts| or Rows &lt; 0 or Columns &lt; 0)</l>
<l>    if (|Rows| # 1 or |Columns| # 1)</l>
<l>        if (|Rows| # 1)</l>
<l>            H_ERR_WIPN3 := 1403</l>
<l>            errNo := H_ERR_WIPN3</l>
<l>        else</l>
<l>            H_ERR_WIPN4 := 1404</l>
<l>            errNo := H_ERR_WIPN4</l>
<l>        endif</l>
<l>        get_error_text (errNo, errorStr)</l>
<l>        throw ([errNo, errorStr])</l>
<l>    endif</l>
<c>    * </c>
<l>    if (Rows &gt;= 0)</l>
<l>        tuple_gen_const (|Texts|, Rows, Rows)</l>
<l>    else</l>
<l>        get_string_extents (WindowHandle, Texts[0], Ascent, Descent, _Width, _Height)</l>
<l>        tuple_gen_const (|Texts|, HeightWin - abs(Rows) - _Height - Margin * 2, Rows)</l>
<l>    endif</l>
<c>    * </c>
<l>    if (Columns &gt;= 0)</l>
<l>        cols := [Columns]</l>
<l>        for I := 0 to |Texts| - 2 by 1</l>
<l>            get_string_extents (WindowHandle, Texts[I], Ascent, Descent, _Width, _Height)</l>
<l>            cols := [cols, cols[|cols| - 1] + _Width + Margin * 2 + ButtonSpace]</l>
<l>        endfor</l>
<l>    else</l>
<l>        cols := [WidthWin - abs(Columns) + Margin * 2]</l>
<l>        for I := |Texts| - 1 to 0 by -1</l>
<l>            get_string_extents (WindowHandle, Texts[I], Ascent, Descent, _Width, _Height)</l>
<l>            cols := [cols, cols[|cols| - 1] - _Width - Margin * 2 - ButtonSpace]</l>
<l>        endfor</l>
<l>        tuple_inverse (cols, cols)</l>
<l>        cols := cols[0 : |cols| - 2]</l>
<l>    endif</l>
<l>    Columns := cols</l>
<l>else</l>
<c>    * ボタンの数だけ位置も指定されている場合は，そのまま使用する。</c>
<l>endif</l>
<c>* </c>
<c>* ボタン背景の領域を生成</c>
<l>gen_empty_obj (Buttons)</l>
<l>for I := 0 to |Texts| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Texts[I], _, _, _Width, _Height)</l>
<l>    gen_rectangle1 (Rectangle, Rows[I], Columns[I], Rows[I] + _Height + Margin * 2, Columns[I] + _Width + Margin * 2)</l>
<l>    concat_obj (Buttons, Rectangle, Buttons)</l>
<l>endfor</l>
<c>* </c>
<c>* 表示・入力</c>
<l>SelectFlag := -1</l>
<l>Clicked := false</l>
<l>mButton := 0</l>
<l>while (true)</l>
<l>    mButtonOld := mButton</l>
<l>    try</l>
<l>        mRow := 1e9</l>
<l>        mColumn := 1e9</l>
<l>        mButton := -1</l>
<l>        get_mposition (WindowHandle, mRow, mColumn, mButton)</l>
<l>    catch (Exception)</l>
<c>        * none</c>
<l>    endtry</l>
<c>    * </c>
<c>    * どのボタンにマウスカーソルがあるかを調べ，処理</c>
<l>    AnyIsInside := false</l>
<l>    for I := 0 to |Texts| - 1 by 1</l>
<l>        msgOffset := 0</l>
<l>        select_obj (Buttons, ButtonSelected, I + 1)</l>
<l>        test_region_point (ButtonSelected, mRow, mColumn, IsInside)</l>
<l>        AnyIsInside := AnyIsInside or IsInside</l>
<l>        if (IsInside)</l>
<l>            SelectFlag := I</l>
<l>            if (mButton = 1)</l>
<l>                msgOffset := 1</l>
<l>            endif</l>
<l>            if (mButtonOld = 1 and mButton = 0)</l>
<l>                Clicked := true</l>
<l>            endif</l>
<l>            dev_set_color (SelectedBgColor)</l>
<l>        else</l>
<l>            dev_set_color (BgColor)</l>
<l>        endif</l>
<l>        dev_display (ButtonSelected)</l>
<l>        if (msgOffset # 0)</l>
<l>            smallest_rectangle1 (ButtonSelected, row1, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect1, row1, col1, row1, col2)</l>
<l>            gen_rectangle1 (rect2, row1, col1, row2, col1)</l>
<l>            concat_obj (rect1, rect2, rect1)</l>
<l>            dev_set_color ('black')</l>
<l>            dev_display (rect1)</l>
<l>        else</l>
<l>            smallest_rectangle1 (ButtonSelected, row1, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect1, row2, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect2, row1, col2, row2, col2)</l>
<l>            concat_obj (rect1, rect2, rect1)</l>
<l>            dev_set_color ('black')</l>
<l>            dev_display (rect1)</l>
<l>        endif</l>
<l>        set_tposition (WindowHandle, Rows[I] + Margin + msgOffset, Columns[I] + Margin + msgOffset)</l>
<l>        dev_set_color (TextColor)</l>
<l>        write_string (WindowHandle, Texts[I])</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (Clicked)</l>
<l>        break</l>
<l>    endif</l>
<c>    * </c>
<c>    * 判断</c>
<l>    if (WaitSelection = 'true')</l>
<l>        if (Clicked)</l>
<l>            break</l>
<l>        endif</l>
<l>    else</l>
<l>        if (mButton # 1)</l>
<l>            if (not Clicked)</l>
<l>                SelectFlag := -1</l>
<l>            endif</l>
<l>            break</l>
<l>        else</l>
<l>            if (0 &lt;= SelectFlag and SelectFlag &lt; |textOptions|)</l>
<l>                if (mButton = 1 and textOptions[SelectFlag] = 'NoReleaseWait')</l>
<l>                    break</l>
<l>                endif</l>
<l>            endif</l>
<l>            if (not AnyIsInside and not Clicked)</l>
<c>                * ボタン外がクリックされていても無視する</c>
<l>                SelectFlag := -1</l>
<l>                break</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>    wait_seconds (0.02)</l>
<l>endwhile</l>
<c>* </c>
<l>SelectedIndex := SelectFlag</l>
<c>* </c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_part (Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>dev_set_draw (DrawMode)</l>
<c>* </c>
<l>* zoom_image_size (DumpedImage, img, Column2Part - Column1Part + 1, Row2Part - Row1Part + 1, 'constant')</l>
<l>* dev_display (img)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="select_button_ex">
<abstract lang="ja_JP">グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。

左ボタンが押された後はボタンが離されるまで制御が返されません。

[SelectedIndex について]
  選択されたボタンのインデックスが返されます (1個目であれば 0 ，2個目であれば 1 , etc.)。
  WaitSelection = 'false' で未選択の場合は -1 が返されます。

[オプションについて]
  Texts の個々の項目に対して ///option と追記することでオプションを指定できます。
  (例)
  Texts に ['button1///NoReleaseWait', 'button2', 'button3'] を指定
  (オプション一覧)
   - 'NoReleaseWait': マウスが離されるまで待ちません。
</abstract>
<chapters lang="ja_JP">
<item>Utilities</item>
</chapters>
<example lang="ja_JP">dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
set_display_font_ex (WindowHandle, 9, 'sans', 'false', 'false', 'jp')

* example 1
select_button_ex (WindowHandle, ['終了'], 10, -10,
        'white', 'dim gray', 'red', 3, 'window', 'true', SelectedIndex)

* example 2
while (true)
    grab_image (Image, AcqHandle)
    dev_display (Image)

    select_button_ex (WindowHandle, ['SaveNow///NoReleaseWait', 'Check'], 10, 10,
            'white', 'dim gray', 'red', 3, 'window', 'false', selectedIndex)
    if (selectedIndex &gt;= 0)
        break
    endif
    
    * ボタンの点滅を低減するためにウェイトを入れる
    wait_seconds (0.05)
endwhile
</example>
<library lang="ja_JP">NEXTAGE Vision Procedures</library>
<see_also>
<item>set_display_font_ex</item>
<item>dev_open_window</item>
<item>get_mposition</item>
</see_also>
<short lang="ja_JP">グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。</short>
<parameters>
<parameter id="BgColor">
<default_value>'dim gray'</default_value>
<description lang="ja_JP">背景色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="Columns">
<default_value>10</default_value>
<description lang="ja_JP">ボタン配置の開始位置 Column (マイナス値にすると右端からの開始位置になる)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>10</item>
<item>-10</item>
<item>[10, 100]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_value>'window'</default_value>
<description lang="ja_JP">'window' のみ利用可</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'window'</item>
<item>'image'</item>
</values>
</parameter>
<parameter id="Margin">
<default_value>3</default_value>
<description lang="ja_JP">ボタン枠と文字列の間隔</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>1</item>
<item>2</item>
<item>3</item>
<item>4</item>
<item>5</item>
</values>
</parameter>
<parameter id="Rows">
<default_value>10</default_value>
<description lang="ja_JP">ボタン配置の開始位置 Row (マイナス値にすると下端からの開始位置になる)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>10</item>
<item>-10</item>
<item>[10, 100]</item>
</values>
</parameter>
<parameter id="SelectedBgColor">
<default_value>'red'</default_value>
<description lang="ja_JP">選択中の背景色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="SelectedIndex">
<description lang="ja_JP">選択されたボタンのインデックス</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>-1</value_min>
</parameter>
<parameter id="TextColor">
<default_value>'white'</default_value>
<description lang="ja_JP">文字列色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="Texts">
<default_value>['OK', 'Cancel']</default_value>
<description lang="ja_JP">ボタン名 (リスト)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'OK'</item>
<item>['OK', 'Cancel']</item>
<item>['1','2','3']</item>
</values>
</parameter>
<parameter id="WaitSelection">
<default_value>'true'</default_value>
<description lang="ja_JP">選択待ちの有無 ('true': 待つ / 'false': 待たない)</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<description lang="ja_JP">ウィンドウハンドル</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_default_contrast_shape_model">
<interface>
<io>
<par name="Image"/>
<par name="Region"/>
</io>
<ic>
<par name="CreateParams"/>
</ic>
<oc>
<par name="Contrast"/>
</oc>
</interface>
<body>
<c>* CrateParamsの要素数チェック</c>
<l>if (|CreateParams| # 25)</l>
<l>    H_ERR_WINPV1 := 1301</l>
<l>    get_error_text (H_ERR_WINPV1, msg)</l>
<l>    throw ([H_ERR_WINPV1, msg])</l>
<l>endif</l>
<c>* </c>
<c>* パラメーター取得</c>
<l>ColorSpace := CreateParams[0]</l>
<l>useChannel := CreateParams[1]</l>
<l>MinScore := CreateParams[2]</l>
<l>AngleStart := number(CreateParams[3])</l>
<l>AngleExtent := number(CreateParams[4])</l>
<l>Greediness := CreateParams[5]</l>
<l>numLevelMax := CreateParams[6]</l>
<c>* </c>
<l>shapeModelType := CreateParams[13]</l>
<l>if (shapeModelType = 'scaled_shape')</l>
<l>    findScaleRCMinMax := [number(CreateParams[7]), number(CreateParams[8])]</l>
<l>    scaleMin := findScaleRCMinMax[0]</l>
<l>    scaleMax := findScaleRCMinMax[1]</l>
<l>elseif (shapeModelType = 'aniso_shape')</l>
<l>    findScaleRCMinMax := [number(CreateParams[9]), number(CreateParams[10]), number(CreateParams[11]), number(CreateParams[12])]</l>
<l>    if (findScaleRCMinMax[0] &lt; findScaleRCMinMax[2])</l>
<l>        scaleMin := findScaleRCMinMax[0]</l>
<l>    else</l>
<l>        scaleMin := findScaleRCMinMax[2]</l>
<l>    endif</l>
<l>    if (findScaleRCMinMax[1] &gt; findScaleRCMinMax[3])</l>
<l>        scaleMax := findScaleRCMinMax[1]</l>
<l>    else</l>
<l>        scaleMax := findScaleRCMinMax[3]</l>
<l>    endif</l>
<l>else</l>
<l>    H_ERR_WIPT1 := 1201</l>
<l>    get_error_text (H_ERR_WIPT1, msg)</l>
<l>    throw ([H_ERR_WIPT1, msg])</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* モデル登録前に，希望の輪郭形状になるパラメーターを確認する</c>
<l>if (false)</l>
<l>    Metric := 'ignore_local_polarity'</l>
<l>else</l>
<l>    Metric := 'ignore_color_polarity'</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>reduce_domain (Image, Region, SubmitImage)</l>
<l>determine_shape_model_params (SubmitImage, 'auto', AngleStart, AngleExtent, scaleMin, scaleMax, 'auto', Metric, 'auto', 'auto', 'all', ParameterName, ParameterValue)</l>
<l>Contrast := [ParameterValue[4], ParameterValue[5]]</l>
<l>return ()</l>
</body>
<docu id="get_default_contrast_shape_model">
<parameters>
<parameter id="Contrast"/>
<parameter id="CreateParams"/>
<parameter id="Image"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_contour_for_find_shape">
<interface>
<oo>
<par name="FoundContours"/>
</oo>
<ic>
<par name="ModelID"/>
<par name="Row"/>
<par name="Column"/>
<par name="Angle"/>
<par name="ScaleR"/>
<par name="ScaleC"/>
</ic>
</interface>
<body>
<c>* </c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<c>* </c>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DRotate)</l>
<l>hom_mat2d_scale (HomMat2DRotate, ScaleR, ScaleC, Row, Column, HomMat2DScale)</l>
<l>affine_trans_contour_xld (ModelContours, FoundContours, HomMat2DScale)</l>
<c>* </c>
<c>* 回転時に輪郭を正しく追従させるための計算</c>
<l>get_shape_model_origin (ModelID, CenterRow, CenterCol)</l>
<l>len := sqrt(pow(CenterRow * ScaleR, 2) + pow(CenterCol * ScaleC, 2))</l>
<l>angle2 := atan2 (CenterRow, CenterCol)</l>
<l>CenterRow2 := len * sin(Angle - angle2)</l>
<l>CenterCol2 := len * cos(Angle - angle2)</l>
<l>gen_cross_contour_xld (cross, Row + CenterRow2, Column - CenterCol2, 20, rad(45))</l>
<c>* </c>
<l>concat_obj (FoundContours, cross, FoundContours)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_contour_for_find_shape">
<abstract lang="ja_JP">入力された二次元画像上の座標、姿勢、スケールに対応するモデルの輪郭を出力します。</abstract>
<short lang="ja_JP">モデルの輪郭を生成します。</short>
<parameters>
<parameter id="Angle">
<description lang="ja_JP">モデルの姿勢</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<description lang="ja_JP">モデル位置の列座標</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="FoundContours">
<description lang="ja_JP">生成されたモデルの輪郭</description>
<multivalue>true</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="ModelID">
<description lang="ja_JP">形状モデルのハンドル</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<description lang="ja_JP">モデル位置の行座標</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleC">
<description lang="ja_JP">モデルの列方向のスケール</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleR">
<description lang="ja_JP">モデルの行方向のスケール</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_warped_mesh">
<interface>
<io>
<par name="VectorField"/>
</io>
<oo>
<par name="WarpedMesh"/>
</oo>
<ic>
<par name="Step"/>
</ic>
</interface>
<body>
<l>gen_empty_obj (WarpedMesh)</l>
<l>count_obj (VectorField, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>select_obj (VectorField, ObjectSelected, Index)</l>
<l>vector_field_to_real (ObjectSelected, DRow, DCol)</l>
<l>get_image_size (VectorField, Width, Height)</l>
<l>for ContR := 0.5 to Height[0] - 1 by Step</l>
<l>Col1 := [0.5:Width[0] - 1]</l>
<l>tuple_gen_const (Width[0] - 1, ContR, Row1)</l>
<l>get_grayval_interpolated (DRow, Row1, Col1, 'bilinear', GrayRow)</l>
<l>get_grayval_interpolated (DCol, Row1, Col1, 'bilinear', GrayCol)</l>
<l>gen_contour_polygon_xld (Contour, GrayRow, GrayCol)</l>
<l>concat_obj (WarpedMesh, Contour, WarpedMesh)</l>
<l>endfor</l>
<l>for ContC := 0.5 to Width[0] - 1 by Step</l>
<l>Row1 := [0.5:Height[0] - 1]</l>
<l>tuple_gen_const (Height[0] - 1, ContC, Col1)</l>
<l>get_grayval_interpolated (DRow, Row1, Col1, 'bilinear', GrayRow)</l>
<l>get_grayval_interpolated (DCol, Row1, Col1, 'bilinear', GrayCol)</l>
<l>gen_contour_polygon_xld (Contour, GrayRow, GrayCol)</l>
<l>concat_obj (WarpedMesh, Contour, WarpedMesh)</l>
<l>endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_warped_mesh">
<parameters>
<parameter id="Step"/>
<parameter id="VectorField"/>
<parameter id="WarpedMesh"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_random_vector_field">
<interface>
<oo>
<par name="VectorField"/>
</oo>
<ic>
<par name="Width"/>
<par name="Height"/>
<par name="MaxDeform"/>
<par name="Sigma"/>
</ic>
</interface>
<body>
<l>WidthVec := 32</l>
<l>HeightVec := 32</l>
<l>gen_image_const (VectorField, 'vector_field', WidthVec, HeightVec)</l>
<l>vector_field_to_real (VectorField, VecRow, VecCol)</l>
<l>for R := 0 to HeightVec - 1 by 1</l>
<l>    for C := 0 to WidthVec - 1 by 1</l>
<l>        DR := (rand(1) - 0.5) * 2 * MaxDeform</l>
<l>        DC := (rand(1) - 0.5) * 2 * MaxDeform</l>
<l>        set_grayval (VecRow, R, C, DR)</l>
<l>        set_grayval (VecCol, R, C, DC)</l>
<l>    endfor</l>
<l>endfor</l>
<l>derivate_gauss (VecRow, VecRowGauss, Sigma, 'none')</l>
<l>derivate_gauss (VecCol, VecColGauss, Sigma, 'none')</l>
<l>zoom_image_size (VecRowGauss, VecRowOrig, Width, Height, 'constant')</l>
<l>zoom_image_size (VecColGauss, VecColOrig, Width, Height, 'constant')</l>
<l>real_to_vector_field (VecRowOrig, VecColOrig, VectorField, 'vector_field_relative')</l>
<l>return ()</l>
</body>
<docu id="gen_random_vector_field">
<parameters>
<parameter id="Height"/>
<parameter id="MaxDeform"/>
<parameter id="Sigma"/>
<parameter id="VectorField"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="create_mvtec_logo_broadened">
<interface>
<oo>
<par name="LogoImage"/>
</oo>
<ic>
<par name="Broadening"/>
<par name="WidthLogo"/>
<par name="WidthImage"/>
<par name="HeightImage"/>
</ic>
</interface>
<body>
<l>Blue := [0,48,117]</l>
<l>Orange := [255,181,41]</l>
<c>* </c>
<c>* Read the image containing the logo</c>
<l>read_image (Image, 'pen/pen-01')</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<c>* Segment the logo</c>
<l>auto_threshold (Image, Regions, 10)</l>
<l>connection (Regions, Regions)</l>
<l>select_shape (Regions, SelectedRegions, ['row1','holes_num'], 'and', [80,0], [100,0])</l>
<l>sort_region (SelectedRegions, SelectedRegions, 'character', 'true', 'row')</l>
<l>closing_rectangle1 (SelectedRegions, Characters, 3, 3)</l>
<l>opening_rectangle1 (Characters, Characters, 5, 5)</l>
<c>* </c>
<c>* Extract the contour</c>
<l>dilation_rectangle1 (Characters, RegionDilation, 5, 5)</l>
<l>erosion_rectangle1 (Characters, RegionErosion, 5, 5)</l>
<l>difference (RegionDilation, RegionErosion, RegionDifference)</l>
<l>count_obj (RegionDifference, Number)</l>
<l>gen_empty_obj (MVTecContours)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (RegionDifference, ObjectSelected, Index)</l>
<l>    reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<l>    edges_sub_pix (ImageReduced, Edges, 'canny', 1.5, 10, 20)</l>
<l>    union_adjacent_contours_xld (Edges, UnionContours, 5, 1, 'attr_keep')</l>
<l>    close_contours_xld (UnionContours, ClosedContours)</l>
<l>    concat_obj (MVTecContours, ClosedContours, MVTecContours)</l>
<l>endfor</l>
<c>* </c>
<c>* Create the colored image of the logo</c>
<l>smallest_rectangle1_xld (MVTecContours, Row1, Column1, Row2, Column2)</l>
<l>Row1 := min(Row1)</l>
<l>Column1 := min(Column1)</l>
<l>Row2 := max(Row2)</l>
<l>Column2 := max(Column2)</l>
<l>WidthLogoOrig := Column2 - Column1 + 1</l>
<l>ScaleFactor := real(WidthLogo) / WidthLogoOrig</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, -0.5 * (Row1 + Row2), -0.5 * (Column1 + Column2), HomMat2DTranslate)</l>
<l>hom_mat2d_scale (HomMat2DTranslate, ScaleFactor, ScaleFactor, 0, 0, HomMat2DScale)</l>
<l>hom_mat2d_translate (HomMat2DScale, 0.5 * HeightImage, 0.5 * WidthImage, HomMat2DComplete)</l>
<l>affine_trans_contour_xld (MVTecContours, MVTecContoursTrans, HomMat2DComplete)</l>
<l>gen_image_const (ImageRed, 'byte', WidthImage, HeightImage)</l>
<l>gen_image_const (ImageGreen, 'byte', WidthImage, HeightImage)</l>
<l>gen_image_const (ImageBlue, 'byte', WidthImage, HeightImage)</l>
<l>compose3 (ImageRed, ImageGreen, ImageBlue, LogoImageTempl)</l>
<l>paint_xld (MVTecContoursTrans, LogoImageTempl, LogoImage, [Blue,Orange,Blue,Blue,Blue,Blue])</l>
<c>* </c>
<c>* Dilate the original logo</c>
<l>if (Broadening &gt; 0)</l>
<l>    gray_dilation_shape (LogoImage, LogoImage, 2 * Broadening + 1, 2 * Broadening + 1, 'octagon')</l>
<l>elseif (Broadening &lt; 0)</l>
<l>    gray_erosion_shape (LogoImage, LogoImage, -2 * Broadening + 1, -2 * Broadening + 1, 'octagon')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="create_mvtec_logo_broadened">
<short lang="en_US">returns a colored image of the MVTec logo</short>
<parameters>
<parameter id="Broadening"/>
<parameter id="HeightImage"/>
<parameter id="LogoImage"/>
<parameter id="WidthImage"/>
<parameter id="WidthLogo"/>
</parameters>
</docu>
</procedure>
<procedure name="create_deformed_mvtec_logo">
<interface>
<io>
<par name="VFFromRow"/>
<par name="VFFromCol"/>
<par name="VFToRow"/>
<par name="VFToCol"/>
<par name="ImageR"/>
<par name="ImageG"/>
<par name="ImageB"/>
</io>
<oo>
<par name="SearchImage"/>
</oo>
<ic>
<par name="T"/>
</ic>
</interface>
<body>
<l>scale_image (VFFromRow, VFFromRowInt, 1.0 - T, 0)</l>
<l>scale_image (VFFromCol, VFFromColInt, 1.0 - T, 0)</l>
<l>scale_image (VFToRow, VFToRowInt, T, 0)</l>
<l>scale_image (VFToCol, VFToColInt, T, 0)</l>
<l>add_image (VFFromRowInt, VFToRowInt, VFRowInt, 1.0, 0)</l>
<l>add_image (VFFromColInt, VFToColInt, VFColInt, 1.0, 0)</l>
<l>real_to_vector_field (VFRowInt, VFColInt, VectorFieldInt, 'vector_field_relative')</l>
<l>unwarp_image_vector_field (ImageR, VectorFieldInt, ImageRDef)</l>
<l>unwarp_image_vector_field (ImageG, VectorFieldInt, ImageGDef)</l>
<l>unwarp_image_vector_field (ImageB, VectorFieldInt, ImageBDef)</l>
<l>compose3 (ImageRDef, ImageGDef, ImageBDef, SearchImage)</l>
<l>return ()</l>
</body>
<docu id="create_deformed_mvtec_logo">
<parameters>
<parameter id="ImageB"/>
<parameter id="ImageG"/>
<parameter id="ImageR"/>
<parameter id="SearchImage"/>
<parameter id="T"/>
<parameter id="VFFromCol"/>
<parameter id="VFFromRow"/>
<parameter id="VFToCol"/>
<parameter id="VFToRow"/>
</parameters>
</docu>
</procedure>
<procedure name="convert_poses_from_2d_to_camera_with_plane_pose">
<interface>
<ic>
<par name="CamParam"/>
<par name="PlanePoseInCam"/>
<par name="Rows"/>
<par name="Columns"/>
<par name="Angles"/>
</ic>
<oc>
<par name="ObjPosesInCam"/>
</oc>
</interface>
<body>
<c>* ///////////////////////////////////////////////////////////////////////</c>
<c>* </c>
<c>* 二次元座標を，カメラ座標系における位置姿勢に変換します．</c>
<c>* この変換には，二次元座標が乗っている平面の，カメラ座標系における姿勢を利用します．</c>
<c>* </c>
<c>* ///////////////////////////////////////////////////////////////////////</c>
<c>* </c>
<l>ObjPosesInCam := []</l>
<c>* </c>
<l>pose_to_hom_mat3d (PlanePoseInCam, cam_H_plane)</l>
<c>* </c>
<l>for i := 0 to |Rows| - 1 by 1</l>
<l>    image_points_to_world_plane (CamParam, PlanePoseInCam, Rows[i], Columns[i], 'm', X, Y)</l>
<l>    hom_mat3d_translate_local (cam_H_plane, X, Y, 0, cam_H_obj)</l>
<l>    hom_mat3d_rotate_local (cam_H_obj, -Angles[i], 'z', cam_H_obj2)</l>
<l>    hom_mat3d_to_pose (cam_H_obj2, pose)</l>
<l>    ObjPosesInCam := [ObjPosesInCam, pose]</l>
<l>endfor</l>
<c>* </c>
<l>return ()</l>
<c>* </c>
</body>
<docu id="convert_poses_from_2d_to_camera_with_plane_pose">
<abstract lang="en_US">Convert 2D coordinate and angle on image to 3D coordinate on given planar coordinate system to determine position and posture in the camera coordinate system.
It is utilized for determining 3D position and posture of a object from 2D recognition result (row, column, angle) of the object in known table plane (3D Pose).

Apply position and posture in the camera coordinate system (tuple length 7) for the plane.

Values in the planar coordinate system will be used for roll and pitch angle of the posture. 

Multiple points can be input. 
In this case, tuple length of ObiPosesInCam for output will be (7 times number of points).
</abstract>
<abstract lang="ja_JP">画像上の2D座標・角度を，与えられた平面座標系における3D座標へ変換し，カメラ座標系における位置･姿勢を求めます。
既知のテーブル平面 （3D Pose） に存在するワークの 2D認識結果 （row, column, angle） から，ワークの 3D位置・姿勢を知りたい場合などに利用できます。

平面には，カメラ座標系における位置･姿勢 （Tuple長 7） を与えてください。

姿勢のロール・ピッチ角は，平面座標系の値が利用されます。

複数の点を入力可能です。
その場合，出力の ObjPosesInCam の Tuple長は （7 * 点の数） となります。
</abstract>
<attention lang="en_US">Unify the size of Rows, Columns, Angles. Exception may throw in the case they are not unified. 
Also, apply angle in image coordinate system (counterclockwise turn by plus and unit in radian).</attention>
<attention lang="ja_JP">Rows, Columns, Angles のサイズを同一にしてください。 同一で無い場合，例外が発生します。

また， Angles は画像座標系で与えてください （プラスで左回り，単位はラジアン）。</attention>
<chapters lang="en_US">
<item>Samples</item>
</chapters>
<chapters lang="ja_JP">
<item>Samples</item>
</chapters>
<library lang="en_US">NEXTAGE Vision Procedures</library>
<library lang="ja_JP">NEXTAGE Vision Procedures</library>
<see_also>
<item>image_points_to_world_plane</item>
<item>hom_mat3d_translate_local</item>
<item>hom_mat3d_rotate_local</item>
</see_also>
<short lang="en_US">Convert 2D coordinate and angle on image to position and posture in the camera coordinate system based on position and posture of the plane.</short>
<short lang="ja_JP">画像上の2D座標・角度を，平面の位置･姿勢を元に，カメラ座標系における位置･姿勢へ変換します。</short>
<successor>
<item>convert_poses_from_camera_to_base</item>
</successor>
<parameters>
<parameter id="Angles">
<description lang="en_US">Angle value on image of object (array)</description>
<description lang="ja_JP">対象物の画像上の Angle値 （のリスト）</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CamParam">
<description lang="en_US">Internal camera parameter</description>
<description lang="ja_JP">内部カメラパラメーター</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Columns">
<description lang="en_US">Column value on image of object (array) </description>
<description lang="ja_JP">対象物の画像上の Column値 （のリスト）</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjPosesInCam">
<description lang="en_US">Position and posture of object in the camera coordinate system (array) [m, deg]</description>
<description lang="ja_JP">カメラ座標系における対象物の位置･姿勢 （のリスト） [m, deg]</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PlanePoseInCam">
<description lang="en_US">Position and posture in plane in the camera coordinate system [m, deg]</description>
<description lang="ja_JP">カメラ座標系における平面の位置･姿勢 [m, deg]</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rows">
<description lang="en_US">Row value on image of object (array)</description>
<description lang="ja_JP">対象物の画像上の Row値 （のリスト）</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
