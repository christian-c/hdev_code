<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.0" halcon_version="11.0.3.4" cs="956160723">
<procedure name="main">
<interface/>
<body>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<c></c>
<l>DataPath := './'</l>
<l>CaltabImageFileName := 'caltab_img_2.jpg'</l>
<l>CaltabFilename := DataPath + 'CalTabData/caltab_40mm.descr'</l>
<l>CaltabThickness := 1.0 / 1000.0</l>
<c></c>
<l>CamParamPath := './CamParams/CamParam_Interior_Raw_3.campar'</l>
<c></c>
<l>ObjectName := 'crml'</l>
<l>PartName := 'b'</l>
<l>*BuildImageFilename := DataPath + ObjectName + '_build_img_' + PartName + '.jpg'</l>
<l>*FindImageFilename := DataPath + ObjectName + '_find_img_' + PartName + '.jpg'</l>
<c></c>
<l>TextColor := 'white'</l>
<l>BgColor1 := 'coral'</l>
<l>BgColor2 := 'red'</l>
<l>Margin := 3</l>
<c></c>
<l>read_cam_par(CamParamPath,CamParamIn)</l>
<l>tuple_gen_const (|CamParamIn| - 7, 0, zeros)</l>
<l>change_radial_distortion_cam_par ('preserve_resolution', CamParamIn, zeros, CamParam)</l>
<l>gen_radial_distortion_map (UnDistMap, CamParamIn, CamParam, 'bilinear')</l>
<c></c>
<l>read_image (CaltabRawImage, CaltabImageFileName)</l>
<l>dev_open_window_fit_image (CaltabRawImage, 0, 0, -1, -1, WindowHandle)</l>
<l>map_image (CaltabRawImage, UnDistMap, CaltabMappedImage)</l>
<l>get_caltab_pose (CaltabMappedImage, CaltabRegion, CaltabFilename, CamParam, CaltabThickness, ReferencePoseInCam)</l>
<l>dev_clear_window ()</l>
<l>dev_display (CaltabMappedImage)</l>
<c></c>
<c>* current graphics context settings:</c>
<l>dev_set_colored (3)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c>* end of graphics context settings</c>
<l>dev_display (CaltabRegion)</l>
<l>disp_3d_coord_system (WindowHandle, CamParam, ReferencePoseInCam, 0.05) </l>
<l>disp_message (WindowHandle, 'Press F5 to Continue.', 'window', 0, 0, 'black', 'true')</l>
<l>stop ()</l>
<c></c>
<l>gen_normalize_map (NormalizeMap, ReferencePoseInCam, CamParam, [], NormalizedScale)</l>
<l>*read_image (WorkRawImage, BuildImageFilename)</l>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>open_framegrabber ('uEye', 1, 1, 0, 0, 0, 0, 'default', 8, 'default', -1, 'false', 'default', '3', 0, -1, AcqHandle)</l>
<l>grab_image_start (AcqHandle, -1)</l>
<l>grab_image_async (WorkRawImage, AcqHandle, -1)</l>
<c>* Image Acquisition 01: Do something</c>
<l>close_framegrabber (AcqHandle)</l>
<l>map_image (WorkRawImage, UnDistMap, WorkMappedImage)</l>
<l>map_image (WorkMappedImage, NormalizeMap, WorkNormImage)</l>
<c></c>
<l>*gen_empty_obj (ModelSelectRegion)</l>
<l>read_region (ModelSelectRegion, './crml_hsv_region.ref')</l>
<l>while(true)</l>
<l>    dev_clear_window ()</l>
<l>    dev_display(WorkNormImage)</l>
<l>    dev_set_draw('margin')</l>
<l>    dev_set_color('red')</l>
<l>    dev_display (ModelSelectRegion)</l>
<l>    disp_message (WindowHandle, 'ワーク領域を選択します。形状を選んでください。', 'window', 0, 0, 'black', 'true')</l>
<l>    Texts := ['Circle', 'Ellipse', 'Line', 'Rectangle1', 'Rectangle2', 'Polygon']</l>
<l>    select_button_ex (WindowHandle, Texts, 16, 0, TextColor, BgColor1, BgColor2, Margin, 'window', 'true', SelectedShape)</l>
<l>    if (SelectedShape = 0)</l>
<l>        ShapeType := 'Circle'</l>
<l>    elseif (SelectedShape = 1)</l>
<l>        ShapeType := 'Ellipse'</l>
<l>    elseif (SelectedShape = 2)</l>
<l>        ShapeType := 'Line'</l>
<l>    elseif (SelectedShape = 3)</l>
<l>        ShapeType := 'Rectangle1'</l>
<l>    elseif (SelectedShape = 4)</l>
<l>        ShapeType := 'Rectangle2'</l>
<l>    else</l>
<l>        ShapeType := 'Polygon'</l>
<l>    endif</l>
<l>    dev_clear_window ()</l>
<l>    dev_display(WorkNormImage)</l>
<l>    dev_set_draw('margin')</l>
<l>    dev_set_color('red')</l>
<l>    dev_display (ModelSelectRegion)</l>
<l>    disp_message (WindowHandle, '矩形で周辺を拡大後、領域を選択してください。', 'window', 0, 0, 'black', 'true')</l>
<l>    make_region (WorkNormImage, ModelSelectRegion, ModelSelectRegion, WindowHandle, ShapeType, 1, 'Add')</l>
<l>    disp_message (WindowHandle, '領域を追加しますか？', 'window', 0, 0, 'black', 'true')</l>
<l>    Texts := ['はい', 'いいえ']</l>
<l>    select_button_ex (WindowHandle, Texts, 16, 0, TextColor, BgColor1, BgColor2, Margin, 'window', 'true', SelectedShape)</l>
<l>    if (SelectedShape = 1)</l>
<l>        break</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l>dev_clear_window ()</l>
<l>dev_display(WorkNormImage)</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_color('green')</l>
<l>dev_display (ModelSelectRegion)</l>
<c></c>
<l>reduce_domain (WorkNormImage, ModelSelectRegion, SubmitImage)</l>
<c></c>
<l>GetFilterParams (WorkNormImage,ModelSelectRegion, OutImage, Results)</l>
<l>dev_clear_window ()</l>
<l>dev_display(WorkNormImage)</l>
<c></c>
<l>dev_set_draw('fill')</l>
<c></c>
<l>dev_set_color('red')</l>
<c></c>
<l>dev_display (OutImage)</l>
<c></c>
<c></c>
<l>dev_set_draw('margin')</l>
<c></c>
<l>dev_set_color('green')</l>
<c></c>
<l>dev_display (ModelSelectRegion)</l>
<c></c>
<l>write_region (ModelSelectRegion, './crml_hsv_model')</l>
<c></c>
<l>*OffsetFilterParams (Image, FilteredObject, -1, 1, -1, 1, -1, 1, Color2, h_min_out, h_max_out, s_min_out, s_max_out, v_min_out, v_max_out)</l>
<c></c>
<l>* SaveFilterParams (Results, CaltabPose)</l>
<l>*ModelID := 4</l>
<l>*Results := [0, 360, 0, 255, 0, 255]</l>
<l>*CaltabPose := [0, 0, 0, 0, 0, 0, 0]</l>
<l>*SaveFilterParams(Results, CaltabPose)</l>
<l>*ReadFilterParams (AreaThreshold, Object_ID, HMin, HMax, SMin, SMax, VMin, VMax)</l>
<l>*ApplyFilter (Image, OutImage, AreaThreshold, ModelID, Object_ID, HMin, HMax, SMin, SMax, VMin, VMax, Results)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="get_hsv_from_file">
<interface>
<ic>
<par name="object_idx"/>
</ic>
<oc>
<par name="h_min"/>
<par name="h_max"/>
<par name="s_min"/>
<par name="s_max"/>
<par name="v_min"/>
<par name="v_max"/>
</oc>
</interface>
<body>
<l>   open_file('/home/christian-c/workspace/hdevelop_test/DBase_/idx.txt','input',File_idx)</l>
<l>   open_file('/home/christian-c/workspace/hdevelop_test/DBase_/obj_list.txt','input',obj_list) </l>
<l>   fread_line (File_idx, OutLine, IsEOF)</l>
<l>   tuple_number (OutLine, idx)</l>
<c>   </c>
<l>   for itr := 1 to idx + 1 by 1</l>
<l>   fread_line (obj_list, str_tst, isEOF)</l>
<l>   if (itr &gt; 1)</l>
<l>   tuple_split(str_tst,' ',substring)</l>
<l>   s_1 := substring[0]</l>
<l>   tuple_split(s_1,':',f_name)</l>
<l>   tuple_split(f_name,'_',sub_names)</l>
<l>   tuple_number (sub_names[1],obj_idx)</l>
<l>   *tuple_number (sub_names[1], obj_num)</l>
<l>   tuple_number (substring[1], h_min)</l>
<l>   tuple_number (substring[2], h_max)</l>
<l>   tuple_number (substring[3], s_min)</l>
<l>   tuple_number (substring[4], s_max)</l>
<l>   tuple_number (substring[5], v_min)</l>
<l>   tuple_split (substring[6],'\n',s_6)</l>
<l>   tuple_number (s_6, v_max)</l>
<l>   if (obj_idx == object_idx)</l>
<l>       break</l>
<l>   endif</l>
<l>   endif</l>
<c>   </c>
<l>   endfor</l>
<l>   return ()</l>
</body>
<docu id="get_hsv_from_file">
<parameters>
<parameter id="h_max"/>
<parameter id="h_min"/>
<parameter id="object_idx"/>
<parameter id="s_max"/>
<parameter id="s_min"/>
<parameter id="v_max"/>
<parameter id="v_min"/>
</parameters>
</docu>
</procedure>
<procedure name="create_hsv_filter">
<interface>
<io>
<par name="Image"/>
<par name="Rectangle"/>
</io>
<oc>
<par name="h_min"/>
<par name="h_max"/>
<par name="s_min"/>
<par name="s_max"/>
<par name="v_min"/>
<par name="v_max"/>
</oc>
</interface>
<body>
<l>reduce_domain (Image, Rectangle, ImageReduced)</l>
<l>decompose3 (ImageReduced, blk_r, blk_g, blk_b)</l>
<l>trans_from_rgb (blk_r, blk_g, blk_b, blk_h, blk_s, blk_v, 'hsv')</l>
<l>min_max_gray (blk_h, blk_h,5,h_min,h_max,h_range)</l>
<l>min_max_gray (blk_s, blk_s,5,s_min,s_max,s_range)</l>
<l>min_max_gray (blk_v, blk_v,5,v_min,v_max,v_range)    </l>
<l>return ()</l>
</body>
<docu id="create_hsv_filter">
<parameters>
<parameter id="Image"/>
<parameter id="Rectangle"/>
<parameter id="h_max"/>
<parameter id="h_min"/>
<parameter id="s_max"/>
<parameter id="s_min"/>
<parameter id="v_max"/>
<parameter id="v_min"/>
</parameters>
</docu>
</procedure>
<procedure name="SaveFilterParams">
<interface>
<ic>
<par name="Results"/>
<par name="CaltabPose"/>
</ic>
</interface>
<body>
<l>h_min := Results[0]</l>
<l>h_max := Results[1]</l>
<l>s_min := Results[2]</l>
<l>s_max := Results[3]</l>
<l>v_min := Results[4]</l>
<l>v_max := Results[5]</l>
<c></c>
<l>try</l>
<l>   open_file('./ObjectDBase/idx.txt','input',File_idx)</l>
<l>   fread_line (File_idx, OutLine, IsEOF)</l>
<l>   tuple_number (OutLine, ctr_0)</l>
<l>   close_file(File_idx)  </l>
<l>   ctr := ctr_0 + 1</l>
<l>   open_file('./ObjectDBase/idx.txt','output',File_idx)</l>
<l>   fwrite_string (File_idx, ctr)</l>
<l>   close_file(File_idx)    </l>
<l>   open_file('./ObjectDBase/obj_list.txt', 'append', FileHandle)</l>
<l>   fwrite_string(FileHandle,['obj_',ctr, ': ',h_min,' ',h_max,' ',s_min,' ',s_max,' ',v_min,' ',v_max,' '])</l>
<l>   fwrite_string(FileHandle,[CaltabPose[0],' ',CaltabPose[1],' ',CaltabPose[2],' ',CaltabPose[3],' ',CaltabPose[4],' ',CaltabPose[5],' ',CaltabPose[6]])</l>
<l>   fnew_line(FileHandle)</l>
<l>   close_file(FileHandle)</l>
<l>catch (Exception)</l>
<l>if (Exception[0] == 5215)</l>
<l>   open_file('./ObjectDBase/idx.txt','output',File_idx)</l>
<l>   fwrite_string (File_idx, 0)</l>
<l>   close_file(File_idx)</l>
<l>   open_file('./ObjectDBase/obj_list.txt', 'output', FileHandle)</l>
<l>   fwrite_string(FileHandle,'&lt;Object ID&gt; &lt;h_min&gt; &lt;h_max&gt; &lt;s_min&gt; &lt;s_max&gt; &lt;v_min&gt; &lt;v_max&gt;')</l>
<l>   fnew_line(FileHandle)</l>
<l>   fwrite_string (FileHandle, 'AreaThreshold 300000')</l>
<l>   fnew_line(FileHandle)</l>
<l>   fwrite_string(FileHandle,['obj_',1, ': ',h_min,' ',h_max,' ',s_min,' ',s_max,' ',v_min,' ',v_max,' ',CaltabPose])</l>
<l>   fwrite_string(FileHandle,[CaltabPose[0],' ',CaltabPose[1],' ',CaltabPose[2],' ',CaltabPose[3],' ',CaltabPose[4],' ',CaltabPose[5],' ',CaltabPose[6]])</l>
<l>   fnew_line(FileHandle)</l>
<l>   close_file(FileHandle)</l>
<l>endif</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="SaveFilterParams">
<parameters>
<parameter id="CaltabPose"/>
<parameter id="Results"/>
</parameters>
</docu>
</procedure>
<procedure name="apply_hsv_filter">
<interface>
<io>
<par name="WorkMappedImage"/>
</io>
<oo>
<par name="ObjectRegion"/>
<par name="OutImage"/>
</oo>
<ic>
<par name="h_min"/>
<par name="h_max"/>
<par name="s_min"/>
<par name="s_max"/>
<par name="v_min"/>
<par name="v_max"/>
<par name="Color"/>
</ic>
<oc>
<par name="Area"/>
<par name="Row"/>
<par name="Col"/>
</oc>
</interface>
<body>
<l>get_image_size (WorkMappedImage, Width, Height)</l>
<l>open_window (0, 0, Width, Height, 0, 'buffer', '', win_handle_1)</l>
<l>decompose3 (WorkMappedImage, Red, Green, Blue)</l>
<l>trans_from_rgb (Red, Green, Blue, Hue, Saturation, Intensity, 'hsv')</l>
<l>threshold (Hue, HueFilter, h_min, h_max)</l>
<c></c>
<l>reduce_domain (Saturation, HueFilter, HSaturation)</l>
<l>threshold (HSaturation,HSaturationFilter, s_min, s_max)</l>
<c></c>
<l>reduce_domain (Intensity, HSaturationFilter, HSIntensity)</l>
<l>threshold (HSIntensity, HSIntensityFilter, v_min, v_max)</l>
<c></c>
<l>closing_circle (HSIntensityFilter, Filtered_Object, 10)</l>
<c></c>
<l>fill_up (Filtered_Object, SelectedRegion)</l>
<c></c>
<l>connection (SelectedRegion, ObjectRegion)</l>
<l>*select_shape_std (ObjectRegion, ObjectRegion, 'max_area', 0)</l>
<c>    </c>
<l>area_center (ObjectRegion, Area, Row, Col)</l>
<c></c>
<l>disp_obj (WorkMappedImage, win_handle_1)</l>
<c></c>
<c>* current graphics context settings:</c>
<l>set_color (win_handle_1, 'red')</l>
<l>set_draw (win_handle_1,'fill')</l>
<c></c>
<c>* end of graphics context settings</c>
<l>disp_obj (ObjectRegion, win_handle_1)</l>
<c></c>
<l>dump_window_image (OutImage, win_handle_1)</l>
<l>close_window (win_handle_1)</l>
<l>return ()</l>
</body>
<docu id="apply_hsv_filter">
<parameters>
<parameter id="Area"/>
<parameter id="Col"/>
<parameter id="Color"/>
<parameter id="ObjectRegion"/>
<parameter id="OutImage"/>
<parameter id="Row"/>
<parameter id="WorkMappedImage"/>
<parameter id="h_max"/>
<parameter id="h_min"/>
<parameter id="s_max"/>
<parameter id="s_min"/>
<parameter id="v_max"/>
<parameter id="v_min"/>
</parameters>
</docu>
</procedure>
<procedure name="GetFilterParams">
<interface>
<io>
<par name="WorkMappedImage"/>
<par name="FilterArea"/>
</io>
<oo>
<par name="OutImage"/>
</oo>
<oc>
<par name="Results"/>
</oc>
</interface>
<body>
<l>get_image_size (WorkMappedImage, Width, Height)</l>
<l>open_window (0,0,Width, Height, 0, 'buffer', '', win_handle)</l>
<c></c>
<l>create_hsv_filter (WorkMappedImage, FilterArea, h_min, h_max, s_min, s_max, v_min, v_max)</l>
<l>apply_hsv_filter (WorkMappedImage, OutImage, Out_Image, h_min, h_max, s_min, s_max, v_min, v_max, 'green', Area, Row, Col)</l>
<c></c>
<l>Results := [h_min, h_max, s_min, s_max, v_min, v_max]</l>
<l>close_window(win_handle)</l>
<l>return ()</l>
</body>
<docu id="GetFilterParams">
<parameters>
<parameter id="FilterArea"/>
<parameter id="OutImage"/>
<parameter id="Results"/>
<parameter id="WorkMappedImage"/>
</parameters>
</docu>
</procedure>
<procedure name="OffsetFilterParams">
<interface>
<io>
<par name="Image"/>
</io>
<oo>
<par name="OutImage"/>
</oo>
<ic>
<par name="h_min_off"/>
<par name="h_max_off"/>
<par name="s_min_off"/>
<par name="s_max_off"/>
<par name="v_min_off"/>
<par name="v_max_off"/>
<par name="Color"/>
</ic>
<oc>
<par name="h_min"/>
<par name="h_max"/>
<par name="s_min"/>
<par name="s_max"/>
<par name="v_min"/>
<par name="v_max"/>
</oc>
</interface>
<body>
<l>dev_open_window_fit_image (Image, 0, 0, -1, -1, win_handle)</l>
<c></c>
<l>gen_rectangle1 (Rectangle, 697.9, 1014.7, 901.9, 1343.5)</l>
<l>create_hsv_filter (Image, Rectangle, h_min, h_max, s_min, s_max, v_min, v_max)</l>
<l>h_min := h_min + h_min_off</l>
<l>h_max := h_max + h_max_off</l>
<l>s_min := s_min + s_min_off</l>
<l>s_max := s_max + s_max_off</l>
<l>v_min := v_min + v_min_off</l>
<l>v_max := v_max + v_max_off</l>
<l>apply_hsv_filter (Image, Filtered_Segment, OutImage, h_min, h_max, s_min, s_max, v_min, v_max, Color, Area, Row, Col)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="OffsetFilterParams">
<parameters>
<parameter id="Color"/>
<parameter id="Image"/>
<parameter id="OutImage"/>
<parameter id="h_max"/>
<parameter id="h_max_off"/>
<parameter id="h_min"/>
<parameter id="h_min_off"/>
<parameter id="s_max"/>
<parameter id="s_max_off"/>
<parameter id="s_min"/>
<parameter id="s_min_off"/>
<parameter id="v_max"/>
<parameter id="v_max_off"/>
<parameter id="v_min"/>
<parameter id="v_min_off"/>
</parameters>
</docu>
</procedure>
<procedure name="ApplyFilter">
<interface>
<io>
<par name="Image"/>
</io>
<oo>
<par name="OutImage"/>
</oo>
<ic>
<par name="AreaThreshold"/>
<par name="ID"/>
<par name="Object_ID"/>
<par name="HMin"/>
<par name="HMax"/>
<par name="SMin"/>
<par name="SMax"/>
<par name="VMin"/>
<par name="VMax"/>
</ic>
<oc>
<par name="Results"/>
</oc>
</interface>
<body>
<l>get_image_size (Image, Width, Height)</l>
<l>open_window (0, 0, Width, Height, 0, 'buffer', '', win_handle)</l>
<l>*apply_hsv_filter (Image, Filtered_Segment, OutImage, HMin[ID], HMax[ID], SMin[ID], SMax[ID], VMin[ID], VMax[ID], 'red', Area, Row, Col)</l>
<c>**************************************************************************</c>
<c></c>
<l>hmin := HMin[ID]</l>
<l>hmax := HMax[ID]</l>
<l>smin := SMin[ID]</l>
<l>smax := SMax[ID]</l>
<l>vmin := VMin[ID]</l>
<l>vmax := VMax[ID]</l>
<c></c>
<l>decompose3 (Image, Red, Green, Blue)</l>
<l>trans_from_rgb (Red, Green, Blue, Hue, Saturation, Intensity, 'hsv')</l>
<l>threshold (Hue, HueFilter, hmin, hmax)</l>
<c></c>
<l>reduce_domain (Saturation, HueFilter, HSaturation)</l>
<l>threshold (HSaturation,HSaturationFilter, smin, smax)</l>
<c></c>
<l>reduce_domain (Intensity, HSaturationFilter, HSIntensity)</l>
<l>threshold (HSIntensity, HSIntensityFilter, vmin, vmax)</l>
<c></c>
<l>closing_circle (HSIntensityFilter, Filtered_Object, 10)</l>
<c></c>
<l>fill_up (Filtered_Object, SelectedRegion)</l>
<c></c>
<l>connection (SelectedRegion, OutImage)</l>
<l>*select_shape_std (ObjectRegion, ObjectRegion, 'max_area', 0)</l>
<c>    </c>
<l>area_center (OutImage, Area, Row, Col)</l>
<c></c>
<l>disp_obj(Image, win_handle)</l>
<c></c>
<l>*dump_window_image (OutImage, win_handle)</l>
<l>*close_window (win_handle_1)</l>
<l>*return ()</l>
<c></c>
<l>tuple_length (Area, Segment_N)</l>
<l>*disp_obj (Image, win_handle_)</l>
<l>*disp_obj (Filtered_Segment, win_handle_)</l>
<l>*set_color (win_handle_, 'red')</l>
<l>AreaOut := []</l>
<l>RowOut := []</l>
<l>ColOut := []</l>
<l>itr := 0</l>
<l>for idx:= 0 to Segment_N-1 by 1</l>
<l>    if (Area[idx] &gt; AreaThreshold)</l>
<l>        tuple_insert (AreaOut, itr, Area[idx], AreaOut)</l>
<l>        tuple_insert (RowOut, itr, Row[idx], RowOut)</l>
<l>        tuple_insert (ColOut, itr, Col[idx], ColOut)</l>
<l>        itr := itr + 1</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>*Results := [Area_, Row_, Col_]</l>
<l>Results := []</l>
<l>tuple_length (AreaOut, Area_N)</l>
<l>for idx := 0 to Area_N-1 by 1</l>
<l>    tmp := [AreaOut[idx], RowOut[idx], ColOut[idx]]</l>
<l>    itr := 3 * idx</l>
<l>    tuple_insert (Results, itr, tmp, Results)</l>
<l>endfor</l>
<c></c>
<l>*for idx := 0 to Area_N-1 by 1</l>
<l>* tuple_insert (Results, idx, Area_, Results)  </l>
<l>*endfor</l>
<l>return ()</l>
</body>
<docu id="ApplyFilter">
<parameters>
<parameter id="AreaThreshold"/>
<parameter id="HMax"/>
<parameter id="HMin"/>
<parameter id="ID"/>
<parameter id="Image"/>
<parameter id="Object_ID"/>
<parameter id="OutImage"/>
<parameter id="Results"/>
<parameter id="SMax"/>
<parameter id="SMin"/>
<parameter id="VMax"/>
<parameter id="VMin"/>
</parameters>
</docu>
</procedure>
<procedure name="ReadFilterParams">
<interface>
<oc>
<par name="AreaThreshold"/>
<par name="Object_ID"/>
<par name="HMin"/>
<par name="HMax"/>
<par name="SMin"/>
<par name="SMax"/>
<par name="VMin"/>
<par name="VMax"/>
</oc>
</interface>
<body>
<l>try </l>
<l>    open_file ('./ObjectDBase/obj_list.txt', 'input', ObjectList)</l>
<l>    isEOF := 0</l>
<l>    nLines :=0</l>
<l>    while (isEOF != 1)</l>
<l>        fread_line (ObjectList, ObjectInfo, isEOF)</l>
<l>        nLines := nLines + 1</l>
<l>    endwhile</l>
<l>    close_file (ObjectList)</l>
<c>    </c>
<l>    Object_ID := []</l>
<l>    HMin := []</l>
<l>    HMax := []</l>
<l>    SMin := []</l>
<l>    SMax := []</l>
<l>    VMin := []</l>
<l>    VMax := []</l>
<l>    open_file ('./ObjectDBase/obj_list.txt', 'input', ObjectList)</l>
<l>    for line_idx := 0 to nLines-2 by 1</l>
<l>        fread_line (ObjectList, ObjectInfo, isEOF)      </l>
<l>        if (line_idx &gt; 0)</l>
<l>           if (line_idx == 1)</l>
<l>              tuple_split(ObjectInfo,' ',ThreshParams) </l>
<l>              tuple_split(ThreshParams[1],'\n',AreaParams)</l>
<l>              tuple_number (AreaParams, AreaThreshold)</l>
<l>           else</l>
<l>               tuple_split(ObjectInfo,' ',ObjSubInfo)</l>
<l>               SubInfo_0 := ObjSubInfo[0]</l>
<l>               tuple_split(SubInfo_0,':',ObjNameStr)</l>
<l>               tuple_split(ObjNameStr,'_',ObjName)</l>
<l>               tuple_number (ObjName[1],ObjID)</l>
<l>               tuple_number (ObjSubInfo[1], h_min)</l>
<l>               tuple_number (ObjSubInfo[2], h_max)</l>
<l>               tuple_number (ObjSubInfo[3], s_min)</l>
<l>               tuple_number (ObjSubInfo[4], s_max)</l>
<l>               tuple_number (ObjSubInfo[5], v_min)</l>
<l>               tuple_split (ObjSubInfo[6],'\n',SubInfo_6)</l>
<l>               tuple_number (SubInfo_6, v_max)</l>
<l>               array_idx := line_idx - 2</l>
<l>               tuple_insert (Object_ID, array_idx, ObjID, Object_ID)</l>
<l>               tuple_insert (HMin, array_idx, h_min, HMin)</l>
<l>               tuple_insert (HMax, array_idx, h_max, HMax) </l>
<l>               tuple_insert (SMin, array_idx, s_min, SMin)</l>
<l>               tuple_insert (SMax, array_idx, s_max, SMax) </l>
<l>               tuple_insert (VMin, array_idx, v_min, VMin)</l>
<l>               tuple_insert (VMax, array_idx, v_max, VMax) </l>
<l>           endif</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>catch (Exception)</l>
<l>    Object_ID := []</l>
<l>    HMin := []</l>
<l>    HMax := []</l>
<l>    SMin := []</l>
<l>    SMax := []</l>
<l>    VMin := []</l>
<l>    VMax := []    </l>
<l>endtry</l>
</body>
<docu id="ReadFilterParams">
<parameters>
<parameter id="AreaThreshold"/>
<parameter id="HMax"/>
<parameter id="HMin"/>
<parameter id="Object_ID"/>
<parameter id="SMax"/>
<parameter id="SMin"/>
<parameter id="VMax"/>
<parameter id="VMin"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_normalize_map">
<interface>
<oo>
<par name="NormalizeMap"/>
</oo>
<ic>
<par name="UndistRefPoseInCam"/>
<par name="UndistCamParam"/>
<par name="ScaleIn"/>
</ic>
<oc>
<par name="ScaleOut"/>
</oc>
</interface>
<body>
<l>project_3d_point (UndistRefPoseInCam[0], UndistRefPoseInCam[1], UndistRefPoseInCam[2], UndistCamParam, row, col)</l>
<l>widthMappedImage := UndistCamParam[|UndistCamParam|-2]</l>
<l>heightMappedImage := UndistCamParam[|UndistCamParam|-1]</l>
<c>* Determine the scale for the mapping</c>
<c>* (here, the scale is determined such that in the</c>
<c>*   surroundings of the given point  the image scale of the</c>
<c>*   mapped image is similar to the image scale of the original image)</c>
<l>distICS := 1</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row, col, 1, centerX, centerY)</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row + distICS, col, 1, belowCenterX, belowCenterY)</l>
<l>image_points_to_world_plane (UndistCamParam, UndistRefPoseInCam, row, col + distICS, 1, rightOfCenterX, rightOfCenterY)</l>
<l>distance_pp (centerY, centerX, belowCenterY, belowCenterX, dist_WCS_Vertical)</l>
<l>distance_pp (centerY, centerX, rightOfCenterY, rightOfCenterX, dist_WCS_Horizontal)</l>
<l>scaleVertical := dist_WCS_Vertical / distICS</l>
<l>scaleHorizontal := dist_WCS_Horizontal / distICS</l>
<l>ScaleOut := (scaleVertical + scaleHorizontal) / 2.0</l>
<c>* Determine the parameters for set_origin_pose such</c>
<c>* that the point given via get_mbutton will be in the center of the</c>
<c>* mapped image</c>
<c>* </c>
<l>if (|ScaleIn| = 1)</l>
<l>    ScaleOut := ScaleIn</l>
<l>endif</l>
<c>* </c>
<l>dx := centerX - ScaleOut * widthMappedImage / 2.0</l>
<l>dy := centerY - ScaleOut * heightMappedImage / 2.0</l>
<l>dz := 0.0</l>
<l>set_origin_pose (UndistRefPoseInCam, dx, dy, dz, PoseForCenteredImage)</l>
<c>* ---------------------------------------------------</c>
<c>* </c>
<c>* Generate normalize map</c>
<l>gen_image_to_world_plane_map (NormalizeMap, UndistCamParam, PoseForCenteredImage, widthMappedImage, heightMappedImage, widthMappedImage, heightMappedImage, ScaleOut, 'bilinear')</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="gen_normalize_map">
<abstract lang="ja_JP">ワークがカメラ座標系で正対するような補正マップを生成します。

画像上のワークサイズが同等になるよう正規化する場合は，空tuple ( [ ] ) を指定してください。

複数段トレイを同一サイズで正規化する場合は，FixedScale に正の数値を指定してください。
</abstract>
<attention lang="ja_JP">正対化の手法自体は， HDevelopサンプル transform_image_into_wcs.dev の内部プロシージャー parameters_image_to_world_plane_centered と同一です。
</attention>
<chapters lang="ja_JP">
<item>Samples</item>
</chapters>
<library lang="ja_JP">NEXTAGE Vision Procedures</library>
<see_also>
<item>gen_image_to_world_plane_map</item>
<item>parameters_image_to_world_plane_centered</item>
</see_also>
<short lang="ja_JP">ワークがカメラ座標系で正対するような補正マップを生成します。</short>
<parameters>
<parameter id="NormalizeMap">
<description lang="ja_JP">正対化するマッピング画像</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
</type_list>
</parameter>
<parameter id="ScaleIn">
<default_value>[]</default_value>
<description lang="ja_JP">スケール
 (詳しくは gen_image_to_world_plane_map の Scale を参照のこと)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleOut">
<description lang="ja_JP">自動計算されたスケール
 (ScaleIn 指定時は同一値が返されます)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="UndistCamParam">
<description lang="ja_JP">歪み補正/平行化済みの内部カメラパラメーター</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="UndistRefPoseInCam">
<description lang="ja_JP">歪み補正/平行化済みのカメラ座標系での平面の位置・姿勢</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_button_ex">
<interface>
<ic>
<par name="WindowHandle"/>
<par name="Texts"/>
<par name="Rows"/>
<par name="Columns"/>
<par name="TextColor"/>
<par name="BgColor"/>
<par name="SelectedBgColor"/>
<par name="Margin"/>
<par name="CoordSystem"/>
<par name="WaitSelection"/>
</ic>
<oc>
<par name="SelectedIndex"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。</c>
<c>* </c>
<c>* </c>
<l>ButtonSpace := 10</l>
<l>dev_set_window (WindowHandle)</l>
<c>* </c>
<c>* オプション文字列を '///' でパースする</c>
<l>tuple_gen_const (|Texts|, '', textOptions)</l>
<l>for i := 0 to |Texts| - 1 by 1</l>
<l>    pos := strstr (Texts[i], '///')</l>
<l>    if (pos &gt;= 0)</l>
<l>        textOptions[i] := Texts[i]{pos + 3 : strlen(Texts[i]) - 1}</l>
<l>        Texts[i] := Texts[i]{0 : pos - 1}</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>get_system (['width', 'height'], SysInfos)</l>
<l>if (SysInfos[0] &lt; WidthWin or SysInfos[1] &lt; HeightWin)</l>
<l>    set_system (['width', 'height'], [max2(SysInfos[0], WidthWin), max2(SysInfos[1], HeightWin)])</l>
<l>endif</l>
<c>* </c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>dev_set_part (0, 0, HeightWin-1, WidthWin-1)</l>
<l>dev_set_draw ('fill')</l>
<c>* </c>
<l>if (false)</l>
<c>    * 画像が表示されたウィンドウをクリックすると現在の part で再表示されてしまうため，見かけを戻すために表示する。</c>
<c>    * 途中のウィンドウサイズ変更は考慮しない。</c>
<l>    dump_window_image (DumpedImage, WindowHandle)</l>
<l>    dev_display (DumpedImage)</l>
<l>else</l>
<c>    * 上記対策を行うと，関数から戻った後にグラフィックウィンドウでウィンドウサイズを 25% などに変更した場合に</c>
<c>    * 不都合が出る (ウィンドウサイズが DumpedImage の 25% などになる)。</c>
<c>    * こちらの方が不便なため，ここでは対処しない。</c>
<c>    * 必要に応じてユーザー側で本コマンド呼出し後に画像の dev_display を行ってもらう。</c>
<l>endif</l>
<c>* </c>
<c>* Rows, Columns を生成</c>
<l>if (|Rows| # |Texts| or |Columns| # |Texts| or Rows &lt; 0 or Columns &lt; 0)</l>
<l>    if (|Rows| # 1 or |Columns| # 1)</l>
<l>        if (|Rows| # 1)</l>
<l>            H_ERR_WIPN3 := 1403</l>
<l>            errNo := H_ERR_WIPN3</l>
<l>        else</l>
<l>            H_ERR_WIPN4 := 1404</l>
<l>            errNo := H_ERR_WIPN4</l>
<l>        endif</l>
<l>        get_error_text (errNo, errorStr)</l>
<l>        throw ([errNo, errorStr])</l>
<l>    endif</l>
<c>    * </c>
<l>    if (Rows &gt;= 0)</l>
<l>        tuple_gen_const (|Texts|, Rows, Rows)</l>
<l>    else</l>
<l>        get_string_extents (WindowHandle, Texts[0], Ascent, Descent, _Width, _Height)</l>
<l>        tuple_gen_const (|Texts|, HeightWin - abs(Rows) - _Height - Margin * 2, Rows)</l>
<l>    endif</l>
<c>    * </c>
<l>    if (Columns &gt;= 0)</l>
<l>        cols := [Columns]</l>
<l>        for I := 0 to |Texts| - 2 by 1</l>
<l>            get_string_extents (WindowHandle, Texts[I], Ascent, Descent, _Width, _Height)</l>
<l>            cols := [cols, cols[|cols| - 1] + _Width + Margin * 2 + ButtonSpace]</l>
<l>        endfor</l>
<l>    else</l>
<l>        cols := [WidthWin - abs(Columns) + Margin * 2]</l>
<l>        for I := |Texts| - 1 to 0 by -1</l>
<l>            get_string_extents (WindowHandle, Texts[I], Ascent, Descent, _Width, _Height)</l>
<l>            cols := [cols, cols[|cols| - 1] - _Width - Margin * 2 - ButtonSpace]</l>
<l>        endfor</l>
<l>        tuple_inverse (cols, cols)</l>
<l>        cols := cols[0 : |cols| - 2]</l>
<l>    endif</l>
<l>    Columns := cols</l>
<l>else</l>
<c>    * ボタンの数だけ位置も指定されている場合は，そのまま使用する。</c>
<l>endif</l>
<c>* </c>
<c>* ボタン背景の領域を生成</c>
<l>gen_empty_obj (Buttons)</l>
<l>for I := 0 to |Texts| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Texts[I], _, _, _Width, _Height)</l>
<l>    gen_rectangle1 (Rectangle, Rows[I], Columns[I], Rows[I] + _Height + Margin * 2, Columns[I] + _Width + Margin * 2)</l>
<l>    concat_obj (Buttons, Rectangle, Buttons)</l>
<l>endfor</l>
<c>* </c>
<c>* 表示・入力</c>
<l>SelectFlag := -1</l>
<l>Clicked := false</l>
<l>mButton := 0</l>
<l>while (true)</l>
<l>    mButtonOld := mButton</l>
<l>    try</l>
<l>        mRow := 1e9</l>
<l>        mColumn := 1e9</l>
<l>        mButton := -1</l>
<l>        get_mposition (WindowHandle, mRow, mColumn, mButton)</l>
<l>    catch (Exception)</l>
<c>        * none</c>
<l>    endtry</l>
<c>    * </c>
<c>    * どのボタンにマウスカーソルがあるかを調べ，処理</c>
<l>    AnyIsInside := false</l>
<l>    for I := 0 to |Texts| - 1 by 1</l>
<l>        msgOffset := 0</l>
<l>        select_obj (Buttons, ButtonSelected, I + 1)</l>
<l>        test_region_point (ButtonSelected, mRow, mColumn, IsInside)</l>
<l>        AnyIsInside := AnyIsInside or IsInside</l>
<l>        if (IsInside)</l>
<l>            SelectFlag := I</l>
<l>            if (mButton = 1)</l>
<l>                msgOffset := 1</l>
<l>            endif</l>
<l>            if (mButtonOld = 1 and mButton = 0)</l>
<l>                Clicked := true</l>
<l>            endif</l>
<l>            dev_set_color (SelectedBgColor)</l>
<l>        else</l>
<l>            dev_set_color (BgColor)</l>
<l>        endif</l>
<l>        dev_display (ButtonSelected)</l>
<l>        if (msgOffset # 0)</l>
<l>            smallest_rectangle1 (ButtonSelected, row1, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect1, row1, col1, row1, col2)</l>
<l>            gen_rectangle1 (rect2, row1, col1, row2, col1)</l>
<l>            concat_obj (rect1, rect2, rect1)</l>
<l>            dev_set_color ('black')</l>
<l>            dev_display (rect1)</l>
<l>        else</l>
<l>            smallest_rectangle1 (ButtonSelected, row1, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect1, row2, col1, row2, col2)</l>
<l>            gen_rectangle1 (rect2, row1, col2, row2, col2)</l>
<l>            concat_obj (rect1, rect2, rect1)</l>
<l>            dev_set_color ('black')</l>
<l>            dev_display (rect1)</l>
<l>        endif</l>
<l>        set_tposition (WindowHandle, Rows[I] + Margin + msgOffset, Columns[I] + Margin + msgOffset)</l>
<l>        dev_set_color (TextColor)</l>
<l>        write_string (WindowHandle, Texts[I])</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (Clicked)</l>
<l>        break</l>
<l>    endif</l>
<c>    * </c>
<c>    * 判断</c>
<l>    if (WaitSelection = 'true')</l>
<l>        if (Clicked)</l>
<l>            break</l>
<l>        endif</l>
<l>    else</l>
<l>        if (mButton # 1)</l>
<l>            if (not Clicked)</l>
<l>                SelectFlag := -1</l>
<l>            endif</l>
<l>            break</l>
<l>        else</l>
<l>            if (0 &lt;= SelectFlag and SelectFlag &lt; |textOptions|)</l>
<l>                if (mButton = 1 and textOptions[SelectFlag] = 'NoReleaseWait')</l>
<l>                    break</l>
<l>                endif</l>
<l>            endif</l>
<l>            if (not AnyIsInside and not Clicked)</l>
<c>                * ボタン外がクリックされていても無視する</c>
<l>                SelectFlag := -1</l>
<l>                break</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>    wait_seconds (0.02)</l>
<l>endwhile</l>
<c>* </c>
<l>SelectedIndex := SelectFlag</l>
<c>* </c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_part (Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>dev_set_draw (DrawMode)</l>
<c>* </c>
<l>* zoom_image_size (DumpedImage, img, Column2Part - Column1Part + 1, Row2Part - Row1Part + 1, 'constant')</l>
<l>* dev_display (img)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="select_button_ex">
<abstract lang="ja_JP">グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。

左ボタンが押された後はボタンが離されるまで制御が返されません。

[SelectedIndex について]
  選択されたボタンのインデックスが返されます (1個目であれば 0 ，2個目であれば 1 , etc.)。
  WaitSelection = 'false' で未選択の場合は -1 が返されます。

[オプションについて]
  Texts の個々の項目に対して ///option と追記することでオプションを指定できます。
  (例)
  Texts に ['button1///NoReleaseWait', 'button2', 'button3'] を指定
  (オプション一覧)
   - 'NoReleaseWait': マウスが離されるまで待ちません。
</abstract>
<chapters lang="ja_JP">
<item>Utilities</item>
</chapters>
<example lang="ja_JP">dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
set_display_font_ex (WindowHandle, 9, 'sans', 'false', 'false', 'jp')

* example 1
select_button_ex (WindowHandle, ['終了'], 10, -10,
        'white', 'dim gray', 'red', 3, 'window', 'true', SelectedIndex)

* example 2
while (true)
    grab_image (Image, AcqHandle)
    dev_display (Image)

    select_button_ex (WindowHandle, ['SaveNow///NoReleaseWait', 'Check'], 10, 10,
            'white', 'dim gray', 'red', 3, 'window', 'false', selectedIndex)
    if (selectedIndex &gt;= 0)
        break
    endif
    
    * ボタンの点滅を低減するためにウェイトを入れる
    wait_seconds (0.05)
endwhile
</example>
<library lang="ja_JP">NEXTAGE Vision Procedures</library>
<see_also>
<item>set_display_font_ex</item>
<item>dev_open_window</item>
<item>get_mposition</item>
</see_also>
<short lang="ja_JP">グラフィックウィンドウにボタンを表示し，選択されたボタンのインデックスを返します。</short>
<parameters>
<parameter id="BgColor">
<default_value>'dim gray'</default_value>
<description lang="ja_JP">背景色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="Columns">
<default_value>10</default_value>
<description lang="ja_JP">ボタン配置の開始位置 Column (マイナス値にすると右端からの開始位置になる)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>10</item>
<item>-10</item>
<item>[10, 100]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_value>'window'</default_value>
<description lang="ja_JP">'window' のみ利用可</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'window'</item>
<item>'image'</item>
</values>
</parameter>
<parameter id="Margin">
<default_value>3</default_value>
<description lang="ja_JP">ボタン枠と文字列の間隔</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>1</item>
<item>2</item>
<item>3</item>
<item>4</item>
<item>5</item>
</values>
</parameter>
<parameter id="Rows">
<default_value>10</default_value>
<description lang="ja_JP">ボタン配置の開始位置 Row (マイナス値にすると下端からの開始位置になる)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>10</item>
<item>-10</item>
<item>[10, 100]</item>
</values>
</parameter>
<parameter id="SelectedBgColor">
<default_value>'red'</default_value>
<description lang="ja_JP">選択中の背景色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="SelectedIndex">
<description lang="ja_JP">選択されたボタンのインデックス</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>-1</value_min>
</parameter>
<parameter id="TextColor">
<default_value>'white'</default_value>
<description lang="ja_JP">文字列色</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'white'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'yellow'</item>
<item>'dim gray'</item>
<item>'gray'</item>
<item>'light gray'</item>
<item>'medium slate blue'</item>
<item>'coral'</item>
<item>'slate blue'</item>
<item>'spring green'</item>
<item>'orange red'</item>
<item>'orange'</item>
<item>'dark olive green'</item>
<item>'pink'</item>
<item>'cadet blue'</item>
</values>
</parameter>
<parameter id="Texts">
<default_value>['OK', 'Cancel']</default_value>
<description lang="ja_JP">ボタン名 (リスト)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'OK'</item>
<item>['OK', 'Cancel']</item>
<item>['1','2','3']</item>
</values>
</parameter>
<parameter id="WaitSelection">
<default_value>'true'</default_value>
<description lang="ja_JP">選択待ちの有無 ('true': 待つ / 'false': 待たない)</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<description lang="ja_JP">ウィンドウハンドル</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
